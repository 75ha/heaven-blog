<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jerry的乐园</title>
    <description>在我看来，编程不仅仅是我与生俱来的使命，也是我快乐的源泉。我正在上海交通大学攻读软件工程硕士学位，同时我作为一名实习生，为Microsoft GBS BI工作。</description>
    <link>http://jerryzou.com/</link>
    <atom:link href="http://jerryzou.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Javascript中的一种深复制实现</title>
        <description>&lt;p&gt;要实现深复制有很多办法，比如最简单的办法有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cloneObj = JSON.parse(JSON.stringify(obj));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种方法好处是非常简单易用，但是坏处也显而易见，这会抛弃对象的constructor，也就是深复制之后，无论这个对象原本的构造函数是什么，在深复制之后都会变成Object。另外诸如&lt;code&gt;RegExp&lt;/code&gt;对象是无法通过这种方式深复制的。&lt;/p&gt;

&lt;p&gt;所以这里我将介绍一种，我自认为很优美的深复制方法，当然可能也存在问题。如果你发现了我的实现方法有什么问题，请及时让我知道~&lt;/p&gt;

&lt;p&gt;先决条件：
1. 对于任何对象，它可能的类型有&lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;RegExp&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; 以及 &lt;code&gt;Object&lt;/code&gt;（所有自定义的对象全都继承于&lt;code&gt;Object&lt;/code&gt;）
2. 我们必须保留对象的构造函数信息（从而使新对象可以使用定义在&lt;code&gt;prototype&lt;/code&gt;上的函数）&lt;/p&gt;

&lt;p&gt;最重要的一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.prototype.clone = function () {
    var Constructor = this.constructor;
    var obj = new Constructor();

    for (var attr in this) {
        if (this.hasOwnProperty(attr)) {
            if (typeof(this[attr]) !== &quot;function&quot;) {
                if (this[attr] === null) {
                    obj[attr] = null;
                }
                else {
                    obj[attr] = this[attr].clone();
                }
            }
        }
    }
    return obj;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义在&lt;code&gt;Object.prototype&lt;/code&gt;上的&lt;code&gt;clone()&lt;/code&gt;函数是整个方法的核心，对于任意一个非js预定义的对象，都会调用这个函数。而对于所有js预定义的对象，如&lt;code&gt;Number&lt;/code&gt;,&lt;code&gt;Array&lt;/code&gt;等，我们就要实现一个&lt;strong&gt;辅助&lt;code&gt;clone()&lt;/code&gt;函数&lt;/strong&gt;来实现完整的克隆过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Method of Array*/
Array.prototype.clone = function () {
    var thisArr = this.valueOf();
    var newArr = [];
    for (var i=0; i&amp;lt;thisArr.length; i++) {
        newArr.push(thisArr[i].clone());
    }
    return newArr;
};

/* Method of Boolean, Number, String*/
Boolean.prototype.clone = function() { return this.valueOf(); };
Number.prototype.clone = function() { return this.valueOf(); };
String.prototype.clone = function() { return this.valueOf(); };

/* Method of Date*/
Date.prototype.clone = function() { return new Date(this.valueOf()); };

/* Method of RegExp*/
RegExp.prototype.clone = function() {
    var pattern = this.valueOf();
    var flags = &#39;&#39;;
    flags += pattern.global ? &#39;g&#39; : &#39;&#39;;
    flags += pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;;
    flags += pattern.multiline ? &#39;m&#39; : &#39;&#39;;
    return new RegExp(pattern.source, flags);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能直接定义在预定义对象的方法上，让人感觉会有些问题。但在我看来这是一种优美的实现方式。&lt;/p&gt;

&lt;p&gt;同时我也在开发一个插件，主要的思想也就是扩展预定义对象的方法。
这个插件叫&lt;code&gt;JustJS&lt;/code&gt;（&lt;a href=&quot;https://github.com/zry656565/JustJS&quot;&gt;Github项目地址&lt;/a&gt;）
有以下一些特性：
1. 同时支持&lt;code&gt;Web&lt;/code&gt;前端和&lt;code&gt;node.js&lt;/code&gt;使用。
2. 直接对预定义对象的方法进行扩展
3. 使用 &lt;code&gt;J(function(){...})&lt;/code&gt; 语句块，决不污染全局命名空间。
目前只写了一小部分，同时也写了些简单的文档，有兴趣的同学可以看一下，也可以加入我，&lt;code&gt;Fork&lt;/code&gt;我的项目，喜欢的同学还可以给&lt;code&gt;Star&lt;/code&gt;！&lt;/p&gt;
</description>
        <pubDate>Tue, 04 Feb 2014 21:33:00 +0000</pubDate>
        <link>http://jerryzou.com/posts/deepcopy/</link>
        <guid isPermaLink="true">http://jerryzou.com/posts/deepcopy/</guid>
      </item>
    
      <item>
        <title>《炉石传说》无法运行的常见错误</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;blzbntbgs800000213003&quot;&gt;&lt;strong&gt;问题1&lt;/strong&gt;: 无法连接到战网服务 BLZBNTBGS80000021(3003)&lt;/h5&gt;
    &lt;p&gt;&lt;img src=&quot;/images/BNerror.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;:使用XP兼容模式后，重新启动战网登陆器
&lt;img src=&quot;/images/BNerror_fix.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section&quot;&gt;&lt;strong&gt;问题2&lt;/strong&gt;: 一直初始化不完的”正在初始化…”&lt;/h5&gt;
    &lt;p&gt;&lt;img src=&quot;/images/endlessInitializing.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;解决办法&lt;/strong&gt;:注销或重新启动计算机即可解决此问题。
&lt;img src=&quot;/images/endlessInitializing_fix.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 01 Feb 2014 15:56:00 +0000</pubDate>
        <link>http://jerryzou.com/posts/hstroubleshoot/</link>
        <guid isPermaLink="true">http://jerryzou.com/posts/hstroubleshoot/</guid>
      </item>
    
      <item>
        <title>学习Javascript的建议</title>
        <description>&lt;p&gt;javascript入门太容易了，导致几乎人人随便看看就能上手，零基础的人学个三五天都能对外宣称自己掌握了js。可是真正掌握js是一件很难的事情。如果在初学一门语言的时候第一想到的是问别人，是很难取得进步的。因为得到答案太容易，而不会去想为什么。而且说实话，js并不适合作为第一门编程语言，它兼容并包，容错性高，但这也意味着一但出错你就很难找到错误的原因。另一方面js有一些优秀的特性对于没有编程经历的人来说也很难发现。&lt;/p&gt;

&lt;p&gt;如果你真想学好js，我有个大概的自学轨迹供你们参考。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一步，学习w3school的js编程。
    &lt;ul&gt;
      &lt;li&gt;w3school提供了最基础的js学习方案，非常粗略，但很适合让你了解客户端js的概貌。立即可以尝试的实例，也可以让js的初学者马上看到效果。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二步，你需要一本系统介绍js的书，比如犀牛书(javascript权威指南)。
    &lt;ul&gt;
      &lt;li&gt;w3school能告诉你的只有js大概是什么。但你接下来要了解的是js真正是什么。犀牛书就充当了这个角色。犀牛书的涵盖面非常广，并且内容非常全，可以为你打开整个js的世界。当然因为犀牛书比较厚，而且看的时候你没办法马上做点什么成果出来，所以这段时间会比较艰难（对我来说还挺有意思的，因为我喜欢js嘛。）但是如果你真能啃完这本书，我相信你也会被js的魅力所吸引。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第三步，了解js的精华——《javascript语言精粹》
    &lt;ul&gt;
      &lt;li&gt;这是一本很薄的书，大概一两天就可以看完。但完全不适合初学者看，当然，相对于看完犀牛书的人来说，就非常适合了。js的诞生太过于仓促，以至于它不得不保留很多糟糕的特性，但你有权利不使用那些。犀牛书告诉了你js是什么，而这本书则告诉你js的精华（与糟粕），看完以后相信你会受益匪浅。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第四步，读代码
    &lt;ul&gt;
      &lt;li&gt;如果你不借助任何第三方js库来完成你的网页，说明你很厉害，但我不提倡你那样做。你完全可以使用优秀的第三方js库来进行更快速的开发，比如jquery,dojo,d3等等。而且更令人兴奋的是，这些别人写的js对你是完全可见的。读代码是对一个人编程能力提升最快的方法，但凭空读代码肯定会让你头痛不已。你如何才能快速理解别人为什么要那样写代码？一来你已经读过两本经典的js书籍，你脑子里已经装上了js的精华，二来，你也可以到各种程序员社区提问。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第五步，向开源社区提交代码。
    &lt;ul&gt;
      &lt;li&gt;读懂别人的代码是学习，而改进别人的代码则是创造了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加油吧，总有一天你可以完成一件属于你自己的、开天辟地的作品。&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Dec 2013 15:56:00 +0000</pubDate>
        <link>http://jerryzou.com/posts/learnjs/</link>
        <guid isPermaLink="true">http://jerryzou.com/posts/learnjs/</guid>
      </item>
    
      <item>
        <title>博客建立</title>
        <description>&lt;p&gt;今天我的博客终于搞定了，首先要谢谢Rasmus Andersson开源了他的博客代码，我才能把博客做成现在这样。
如果你喜爱这个博客，可以通过点击&lt;a href=&quot;https://github.com/zry656565/jblog/&quot;&gt;这里&lt;/a&gt;来获取源代码。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JerryBlog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello, world.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;JerryBlog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 16 Dec 2013 10:00:00 +0000</pubDate>
        <link>http://jerryzou.com/posts/opentopublic/</link>
        <guid isPermaLink="true">http://jerryzou.com/posts/opentopublic/</guid>
      </item>
    
      <item>
        <title>C语言中可能被你忽视的小细节</title>
        <description>&lt;ol&gt;
  &lt;li&gt;EOF是文件结束符，它的值是-1.&lt;br /&gt;
因此用于接收getchar()的返回值的变量一般用int而不是char。&lt;/li&gt;
  &lt;li&gt;声明数组时，如int n[10]&lt;br /&gt;
方括号中的数字必须为常数，因为这是静态声明数组。&lt;br /&gt;
也有动态声明数组的方式，那会用到指针，这在后面讨论。&lt;/li&gt;
  &lt;li&gt;在C语言中，所有函数参数都是“通过值”传递的。（如果你真的想在函数中修改主调函数的变量，你可以传地址，其实也就是传指针，这个也是后话）&lt;/li&gt;
  &lt;li&gt;处理数组时一定要时刻注意边界值的处理（是否溢出）&lt;/li&gt;
  &lt;li&gt;变量和函数的extern声明通常写在头文件中。&lt;/li&gt;
  &lt;li&gt;如果函数没有参数，在声明该函数时需要使用void关键词显式声明。因为ANSI C为了兼容老版本的C语言，把空参数表看成老版本的函数声明方式，而对参数表不做任何检查。就像这样：
&amp;lt;div style=&quot;margin-left: 40px&quot;&amp;gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:本文原发布于我的CSDN博客&lt;a href=&quot;http://blog.csdn.net/zry656565&quot;&gt;天上之海原&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jul 2013 15:37:00 +0000</pubDate>
        <link>http://jerryzou.com/posts/tipsforC/</link>
        <guid isPermaLink="true">http://jerryzou.com/posts/tipsforC/</guid>
      </item>
    
      <item>
        <title>搞清大数端小数端</title>
        <description>&lt;p&gt;对于同样一个数0x123456。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大数端的存储方法是：
    &lt;table&gt;
      &lt;tr&gt;&lt;td&gt;地址&lt;/td&gt;&lt;td&gt;值&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;0x00&lt;/td&gt;&lt;td&gt;0x12&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;0x01&lt;/td&gt;&lt;td&gt;0x34&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;0x02&lt;/td&gt;&lt;td&gt;0x56&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
    &lt;p&gt;&lt;br /&gt;
  &lt;strong&gt;大数端记忆方法：低地址存高（大）位&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;而小数端的存储方法是：
    &lt;table&gt;
      &lt;tr&gt;&lt;td&gt;地址&lt;/td&gt;&lt;td&gt;值&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;0x00&lt;/td&gt;&lt;td&gt;0x56&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;0x01&lt;/td&gt;&lt;td&gt;0x34&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;0x02&lt;/td&gt;&lt;td&gt;0x12&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
    &lt;p&gt;&lt;br /&gt;
  &lt;strong&gt;小数端记忆方法：低地址存低（小）&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们日常生活中常见的IA-32位体系架构一般都是小数端存储方法。&lt;/li&gt;
  &lt;li&gt;而IA-64则同时采用大数端和小数端的存储方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但需要注意的是，现在很常见的家装64位的windows系统可不算真正的64位系统。真正的64位体系结构与32位体系结构完全不同，32位体系结构的程序在64位体系结构上的机器上根本运行不了。因为两者根本就使用了完全不同的指令集。&lt;br /&gt;
其实啊，家装的64位windows系统还是属于32位体系结构EM64T。而EM64T前面的E就是Extended的简称啦（即32位的扩展，实际上是48位系统）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:本文原发布于我的CSDN博客&lt;a href=&quot;http://blog.csdn.net/zry656565&quot;&gt;天上之海原&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jul 2013 15:37:00 +0000</pubDate>
        <link>http://jerryzou.com/posts/storageMethod/</link>
        <guid isPermaLink="true">http://jerryzou.com/posts/storageMethod/</guid>
      </item>
    
  </channel>
</rss>
